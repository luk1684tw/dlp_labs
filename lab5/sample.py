from __future__ import unicode_literals, print_function, division
from io import open
import unicodedata
import string
import re
import random
import time
import math
import torch
import torch.nn as nn
import torch.distributions as dist
from torch import optim
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')
import matplotlib.ticker as ticker
import numpy as np
from os import system
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu




"""========================================================================================
The sample.py includes the following template functions:

1. Encoder, decoder
2. Training function
3. BLEU-4 score function
4. Gaussian score function

You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.

1. The reparameterization trick
2. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
3. Output your results (BLEU-4 score, conversion words, Gaussian score, generation words)
4. Plot loss/score
5. Load/save weights

There are some useful tips listed in the lab assignment.
You should check them before starting your lab.
========================================================================================"""

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# device = torch.device("cpu")
SOS_token = 0
EOS_token = 1
#----------Hyper Parameters----------#
hidden_size = 256
#The number of vocabulary
vocab_size = 28
teacher_forcing_ratio = 1.0
empty_input_ratio = 0.1
KLD_weight = 0.0
LR = 0.05
MAX_LENGTH = 128
train_path = './train.txt'
test_path = './test.txt'
tense_type = ['sp', 'tp', 'pp', 'p']
train_data, test_data = list(), list()

with open(train_path, 'r') as train:
    for words in train:
        train_data.append(words.split())

with open(test_path, 'r') as data:
    for words in data:
        test_data.append(words.split())


################################
#Example inputs of compute_bleu
################################
#The target word
reference = 'accessed'
#The word generated by your model
output = 'access'

#compute BLEU-4 score
def compute_bleu(output, reference):
    cc = SmoothingFunction()
    if len(reference) == 3:
        weights = (0.33,0.33,0.33)
    else:
        weights = (0.25,0.25,0.25,0.25)
    return sentence_bleu([reference], output,weights=weights,smoothing_function=cc.method1)


"""============================================================================
example input of Gaussian_score

words = [['consult', 'consults', 'consulting', 'consulted'],
['plead', 'pleads', 'pleading', 'pleaded'],
['explain', 'explains', 'explaining', 'explained'],
['amuse', 'amuses', 'amusing', 'amused'], ....]

the order should be : simple present, third person, present progressive, past
============================================================================"""

def Gaussian_score(words):
    words_list = []
    score = 0
    yourpath = './train.txt' #should be your directory of train.txt
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[3] = word[3].strip('\n')
            words_list.extend([word])
        for t in words:
            for i in words_list:
                if t == i:
                    score += 1
    return score/len(words)

#Encoder
class EncoderRNN(nn.Module):
    def __init__(self, input_size, hidden_size):
        super(EncoderRNN, self).__init__()
        self.hidden_size = hidden_size

        self.embedding = nn.Embedding(input_size, hidden_size)
        self.embedding_cls = nn.Embedding(4 ,8)
        self.lstm = nn.LSTM(hidden_size, hidden_size)


        self.fc01 = nn.Linear(self.hidden_size*2, 64)
        self.fc02 = nn.Linear(self.hidden_size*2, 64)

        self.fc11 = nn.Linear(self.hidden_size*2, 64)
        self.fc12 = nn.Linear(self.hidden_size*2, 64)

    def forward(self, input, hidden, src_tense):
        target_tense = self.embedding_cls((src_tense == 1).nonzero())

        hidden = (torch.cat((hidden[0], target_tense), 2), torch.cat((hidden[1], target_tense), 2))

        embedded = self.embedding(input)
        output = embedded
        output, hidden = self.lstm(output, hidden)


        h = torch.cat((hidden[0], hidden[1]), 2)
        self.mean_0 = self.fc01(torch.flatten(h))
        self.log_var_0 = self.fc02(torch.flatten(h))

        self.mean_1 = self.fc11(torch.flatten(h))
        self.log_var_1 = self.fc12(torch.flatten(h))

        self.z0 = self.mean_0 + mul_normal.sample().to(device) * torch.exp(self.log_var_0 / 2)
        self.z1 = self.mean_1 + mul_normal.sample().to(device) * torch.exp(self.log_var_1 / 2)

        return output, (self.z0, self.z1)

    def initHidden(self):
        return torch.zeros(1, 1, self.hidden_size - 8, device=device)

#Decoder
class DecoderRNN(nn.Module):
    def __init__(self, hidden_size, output_size):
        super(DecoderRNN, self).__init__()
        self.hidden_size = hidden_size

        self.embedding = nn.Embedding(output_size, hidden_size)
        self.fc0 = nn.Linear(64, 256 - 8)
        self.fc1 = nn.Linear(64, 256 - 8)
        self.embedding_cls = nn.Embedding(4 ,8)
        self.lstm = nn.LSTM(hidden_size, hidden_size)
        self.out = nn.Linear(hidden_size, output_size)
        self.first = True

    def forward(self, input, hidden, dst_tense):
        output = self.embedding(input).view(1, 1, -1)
        output = F.relu(output)

        # print((dst_tense == 1).nonzero()[0])

        if self.first:
            target_tense = torch.flatten(self.embedding_cls((dst_tense == 1).nonzero()))       
            target_tense = target_tense.type(torch.cuda.FloatTensor)

            latent = self.fc1(torch.flatten(hidden[0]))
            # latent = F.relu(latent)
            latent = torch.cat((latent, target_tense), 0).view(1, 1, -1)
            

            cell = self.fc1(torch.flatten(hidden[1]))
            # cell = F.relu(cell)
            cell = torch.cat((cell, target_tense), 0).view(1, 1, -1)
            hidden = (latent, cell)

            self.first = False

        output, hidden = self.lstm(output, hidden)
        output = self.out(output[0])

        return output, hidden

    def initHidden(self):
        return torch.zeros(1, 1, self.hidden_size, device=device)


def train(input_tensor, target_tensor, encoder, decoder, encoder_optimizer, decoder_optimizer, criterion, max_length=MAX_LENGTH):
    encoder_hidden = (encoder.initHidden(), encoder.initHidden())

    encoder_optimizer.zero_grad()
    decoder_optimizer.zero_grad()

    target_length = input_tensor.size(0)

    loss = 0

    #----------sequence to sequence part for encoder----------#
    encoder_output, encoder_hidden = encoder(input_tensor, encoder_hidden, target_tensor)

    decoder_input = torch.tensor([[SOS_token]], device=device)

    decoder_hidden = encoder_hidden
    
    decoder.first = True

    use_teacher_forcing = True if random.random() < teacher_forcing_ratio else False
	
    #----------sequence to sequence part for decoder----------#
    if use_teacher_forcing:
        # Teacher forcing: Feed the target as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden = decoder(
                decoder_input, decoder_hidden, target_tensor)
            loss += criterion(decoder_output, input_tensor[di])
            decoder_input = input_tensor[di]  # Teacher forcing


    else:
        # Without teacher forcing: use its own predictions as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden = decoder(
                decoder_input, decoder_hidden, target_tensor)
            topv, topi = decoder_output.topk(1)
            decoder_input = topi.squeeze().detach()  # detach from history as input
            loss += criterion(decoder_output, input_tensor[di])
            if decoder_input.item() == EOS_token:
                break
    
    c_loss = loss
    kl_loss = -0.5 * (0.9 * torch.sum(1 + encoder.log_var_0 - encoder.mean_0.pow(2) - encoder.log_var_0.exp()) 
                        + 0.1 * torch.sum(1 + encoder.log_var_1 - encoder.mean_1.pow(2) - encoder.log_var_1.exp()))
    loss += KLD_weight*kl_loss.to(device)
    loss.backward()

    encoder_optimizer.step()
    decoder_optimizer.step()

    return loss.item() / target_length, c_loss, kl_loss


def asMinutes(s):
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)


def timeSince(since, percent):
    now = time.time()
    s = now - since
    es = s / (percent)
    rs = es - s
    return '%s (- %s)' % (asMinutes(s), asMinutes(rs))


def plot_curve(content, n_iters, y_label, fig_name):
    fig = plt.figure(figsize=(12, 8), dpi=300)
    plt.title(f'{fig_name}')
    plt.xlabel('Epoch')
    plt.ylabel(y_label)
    
    plt.plot(content, linewidth=0.8)
        
    plt.savefig(f'{fig_name}.jpg')
    plt.show()
    
    return


def trainIters(encoder, decoder, n_iters, KLD_mode, print_every=1000, plot_every=100, learning_rate=0.03):
    global KLD_weight, teacher_forcing_ratio

    start = time.time()
    cl_losses = []
    kl_losses = []
    bleu_scores = []
    max_score = 0
    encoder_optimizer = optim.SGD(encoder.parameters(), lr=learning_rate)
    decoder_optimizer = optim.SGD(decoder.parameters(), lr=learning_rate)

    encoder_scheduler = optim.lr_scheduler.MultiStepLR(encoder_optimizer, [4, 8, 12, 16], 0.08)
    decoder_scheduler = optim.lr_scheduler.MultiStepLR(decoder_optimizer, [4, 8, 12, 16], 0.08)

    criterion = nn.CrossEntropyLoss()

    for epoch in range(n_iters):
        training_pairs = [train_tensors[random.randint(0, len(train_tensors) - 1)] for i in range(10000)]
        encoder.train()
        decoder.train()
        print_loss_total = 0  # Reset every print_every
        plot_loss_total = 0  # Reset every plot_every

        print('=' * 40)
        print(f'Epoch {epoch + 1} starts...\n')
        if KLD_mode != 'mono':
            KLD_weight = 0

        plot_loss_CE = []
        plot_loss_KL = []
        for iter in range(1, 10001):
            training_pair = training_pairs[iter-1]
            input_tensor = training_pair[0]
            target_tensor = training_pair[1]

            loss, c_loss, kl_loss = train(input_tensor, target_tensor, encoder,
                        decoder, encoder_optimizer, decoder_optimizer, criterion)
            plot_loss_CE.append(c_loss)
            plot_loss_KL.append(kl_loss)
            print_loss_total += loss
            plot_loss_total += loss

            if KLD_mode == 'mono' and KLD_weight < 1:
                KLD_weight += 0.0001
            else:
                if KLD_weight < 1:
                    KLD_weight += 0.0001

            if teacher_forcing_ratio >= 0.00001:
                teacher_forcing_ratio -= 0.00001


            if iter % print_every == 0:
                print_loss_avg = print_loss_total / print_every
                print_loss_total = 0
                print('%s (%d %d%%) %.4f' % (timeSince(start, iter / 10000),
                                            iter, iter / 10000 * 100, print_loss_avg))

        encoder_scheduler.step()
        decoder_scheduler.step()

        encoder.eval()
        decoder.eval()
        score = evaluate(encoder, decoder, test_tensors, test_labels, True)
        bleu_scores.append(score)
        gaussian_noise(decoder)
        teacher_forcing_ratio += 0.6
        cl_losses.append(sum(plot_loss_CE) / 10000)
        kl_losses.append(sum(plot_loss_KL) / 10000)

        if score > max_score:
            torch.save(encoder.state_dict(), 'encoder_best.pth')
            torch.save(decoder.state_dict(), 'decoder_best.pth')
        else:
            encoder = torch.load_state_dict(torch.load('encoder_best.pth'))
            decoder = torch.load_state_dict(torch.load('decoder_best.pth'))

    plot_curve(cl_losses, n_iters, 'Cross Entropy Loss', 'CELoss.jpg')
    plot_curve(kl_losses, n_iters, 'KL Loss', 'KLLoss.jpg')
    plot_curve(bleu_scores, n_iters, 'BLEU Scores', 'bleu.jpg')

    return 

def translate(dictionary, code):
    res = ''
    for c in code:
        for key, val in dictionary.items():
            if val == c and c > 1:
                res += key
    return res

def evaluate(encoder, decoder, test_data, test_label, print_info=True):
    with torch.no_grad():
        scores = list()
        for data, label in zip(test_data, test_label):
            # print(data)
            # print(label)
            encoder_hidden = (encoder.initHidden(), encoder.initHidden())
            decoder.first = True
            dst_tense = [0] * 4
            dst_tense[label[1]] = 1
            # print(dst_tense)
            dst_tense = torch.from_numpy(np.array(dst_tense)).type(torch.LongTensor).to(device)
            
            encoder_output, hidden_state = encoder(data[0], encoder_hidden, data[1])
            
            decoder_input = torch.tensor([[SOS_token]], device=device)

            decoder_hidden = hidden_state
            
            decoder_outputs = list()
            
            for d in range(100):
                decoder_output, decoder_hidden = decoder(decoder_input, decoder_hidden, dst_tense)
                
                topv, topi = decoder_output.data.topk(1)
                if topi.item() == EOS_token:
                    break
                else:
                    decoder_outputs.append(translate(vocab, [topi.item()]))
                decoder_input = topi.squeeze().detach()
            
            input_case = translate(vocab, data[0].T[0].tolist())
            output = "".join(decoder_outputs)
            score = compute_bleu(output, label[0])
            scores.append(score)
            
            if print_info:
                print('='*40)
                print('Input: ', input_case)
                print('Label: ', label[0])
                print('Model Output: ', output)
                print(f'Scores: {score}\n')
    score_avg = sum(scores)/len(scores)
    print('Average Score: ', score_avg)
    
    return score_avg


def gaussian_noise(decoder, print_info=False):
    scores = list()
    for i in range(100):
        input_hidden = mul_normal.sample().to(device)
        input_cell = mul_normal.sample().to(device)
        word_list = list()
        for tense in range(4):
            decoder.first = True
            tense_tensor = [0] * 4
            tense_tensor[tense] = 1
            tense_tensor = torch.from_numpy(np.array(tense_tensor)).type(torch.LongTensor).to(device)

            decoder_input = torch.tensor([[SOS_token]], device=device)

            decoder_hidden = (input_hidden, input_cell)

            decoder_outputs = list()
            
            for d in range(100):
                decoder_output, decoder_hidden = decoder(decoder_input, decoder_hidden, tense_tensor)
                
                topv, topi = decoder_output.data.topk(1)
                if topi.item() == EOS_token:
                    break
                else:
                    decoder_outputs.append(translate(vocab, [topi.item()]))
                decoder_input = topi.squeeze().detach()
            
            output = "".join(decoder_outputs)
            word_list.append(output)
        if print_info:
            print(word_list)
        scores.append(word_list)
    
    print('Gaussian Scores:', Gaussian_score(scores))

    return

            


# return a tuple of tensors
# tensor1 : [seq_len, 1]
# tensor2: [4] as one-hot encoding of classes.
def make_tensors(word, i):    
    # 1. translate to indexes & add EOS
    word_encode = [vocab[alphabet] for alphabet in word]
    # word_encode = [vocab['SOS']] + word_encode
    word_encode.append(vocab['EOS'])

    # 2. adjust shape and cast to tensor
    word_encode = np.array(word_encode)
    word_encode = word_encode.T
    word_encode = torch.from_numpy(word_encode).type(torch.LongTensor).unsqueeze(1)
    
    cls = [0] * 4
    cls[i] = 1
    cls = torch.from_numpy(np.array(cls)).type(torch.LongTensor)

    if torch.cuda.is_available():
        word_encode = word_encode.to(device)
        cls = cls.to(device)
    
    return (word_encode, cls)


def create_pairs(samples, mode):
    pairs = list()
    test_label = list()

    for idx, words in enumerate(samples):
        if mode == 'train':
            for i, word in enumerate(words):
                input_tensor = make_tensors(word, i)
                pairs.append(input_tensor)

        else:
            test_label.append((words[1], tense_type.index(test_tense[idx][1])))
            i = tense_type.index(test_tense[idx][0])
            input_tensor = make_tensors(words[0], i)
            pairs.append(input_tensor)

    if mode == 'train':
        return pairs
    else:
        return pairs, test_label




vocab = dict()
vocab['SOS'] = SOS_token
vocab['EOS'] = EOS_token

for i, alphabet in enumerate(string.ascii_lowercase):
    vocab[alphabet] = i + 2

test_tense = [
    ['sp', 'p'],
    ['sp', 'pp'],
    ['sp', 'tp'],
    ['sp', 'tp'],
    ['p', 'tp'],
    ['sp', 'pp'],
    ['p', 'sp'],
    ['pp', 'sp'],
    ['pp', 'p'],
    ['pp', 'tp']
]

train_tensors = create_pairs(train_data, 'train') # [([seq_len, 1], [4])]

test_tensors, test_labels = create_pairs(test_data, 'test') # [([seq_len, 1], [4])] , [[label, class]]

mul_normal = dist.multivariate_normal.MultivariateNormal(torch.zeros(64), torch.eye(64))
encoder1 = EncoderRNN(vocab_size, hidden_size).to(device)
decoder1 = DecoderRNN(hidden_size, vocab_size).to(device)
# trainIters(encoder1, decoder1, 50, 'cyc', print_every=500)

print('=' * 40)
encoder1.load_state_dict(torch.load('encoder_best.pth'))
decoder1.load_state_dict(torch.load('decoder_best.pth'))

evaluate(encoder1, decoder1, test_tensors, test_labels)
print ('='*40)
gaussian_noise(decoder1, True)